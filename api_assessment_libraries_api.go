/*
Codio API

Documentation APIs v1.0

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package codioapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AssessmentLibrariesAPIAPIService AssessmentLibrariesAPIAPI service
type AssessmentLibrariesAPIAPIService service

type ApiAssessmentLibraryCreateAssessmentRequest struct {
	ctx context.Context
	ApiService *AssessmentLibrariesAPIAPIService
	libraryId string
	bundle *os.File
	assessment *map[string]interface{}
}

// Optional file archive data to be published
func (r ApiAssessmentLibraryCreateAssessmentRequest) Bundle(bundle *os.File) ApiAssessmentLibraryCreateAssessmentRequest {
	r.bundle = bundle
	return r
}

func (r ApiAssessmentLibraryCreateAssessmentRequest) Assessment(assessment map[string]interface{}) ApiAssessmentLibraryCreateAssessmentRequest {
	r.assessment = &assessment
	return r
}

func (r ApiAssessmentLibraryCreateAssessmentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssessmentLibraryCreateAssessmentExecute(r)
}

/*
AssessmentLibraryCreateAssessment Create assessment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId Library id
 @return ApiAssessmentLibraryCreateAssessmentRequest
*/
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryCreateAssessment(ctx context.Context, libraryId string) ApiAssessmentLibraryCreateAssessmentRequest {
	return ApiAssessmentLibraryCreateAssessmentRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryCreateAssessmentExecute(r ApiAssessmentLibraryCreateAssessmentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssessmentLibrariesAPIAPIService.AssessmentLibraryCreateAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/assessment_library/{libraryId}/assessment"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var bundleLocalVarFormFileName string
	var bundleLocalVarFileName     string
	var bundleLocalVarFileBytes    []byte

	bundleLocalVarFormFileName = "bundle"
	bundleLocalVarFile := r.bundle

	if bundleLocalVarFile != nil {
		fbs, _ := io.ReadAll(bundleLocalVarFile)

		bundleLocalVarFileBytes = fbs
		bundleLocalVarFileName = bundleLocalVarFile.Name()
		bundleLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: bundleLocalVarFileBytes, fileName: bundleLocalVarFileName, formFileName: bundleLocalVarFormFileName})
	}
	if r.assessment != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "assessment", r.assessment, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssessmentLibraryGetAssessmentRequest struct {
	ctx context.Context
	ApiService *AssessmentLibrariesAPIAPIService
	libraryId string
	id string
}

func (r ApiAssessmentLibraryGetAssessmentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssessmentLibraryGetAssessmentExecute(r)
}

/*
AssessmentLibraryGetAssessment Get assessment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId Library id
 @param id Assessment id
 @return ApiAssessmentLibraryGetAssessmentRequest
*/
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryGetAssessment(ctx context.Context, libraryId string, id string) ApiAssessmentLibraryGetAssessmentRequest {
	return ApiAssessmentLibraryGetAssessmentRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryGetAssessmentExecute(r ApiAssessmentLibraryGetAssessmentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssessmentLibrariesAPIAPIService.AssessmentLibraryGetAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/assessment_library/{libraryId}/assessment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssessmentLibrarySearchRequest struct {
	ctx context.Context
	ApiService *AssessmentLibrariesAPIAPIService
	libraryId string
	count *string
	offset *string
	free *SocrateTagSearchExample
}

// Optional count parameter
func (r ApiAssessmentLibrarySearchRequest) Count(count string) ApiAssessmentLibrarySearchRequest {
	r.count = &count
	return r
}

// Optional offset parameter
func (r ApiAssessmentLibrarySearchRequest) Offset(offset string) ApiAssessmentLibrarySearchRequest {
	r.offset = &offset
	return r
}

// Free form tag search is allowed
func (r ApiAssessmentLibrarySearchRequest) Free(free SocrateTagSearchExample) ApiAssessmentLibrarySearchRequest {
	r.free = &free
	return r
}

func (r ApiAssessmentLibrarySearchRequest) Execute() (*SocrateAnswerExample, *http.Response, error) {
	return r.ApiService.AssessmentLibrarySearchExecute(r)
}

/*
AssessmentLibrarySearch Search assessments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId Library id
 @return ApiAssessmentLibrarySearchRequest
*/
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibrarySearch(ctx context.Context, libraryId string) ApiAssessmentLibrarySearchRequest {
	return ApiAssessmentLibrarySearchRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return SocrateAnswerExample
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibrarySearchExecute(r ApiAssessmentLibrarySearchRequest) (*SocrateAnswerExample, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SocrateAnswerExample
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssessmentLibrariesAPIAPIService.AssessmentLibrarySearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/assessment_library/{libraryId}/assessment"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.free != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "free", r.free, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssessmentLibraryUpdateAssessmentRequest struct {
	ctx context.Context
	ApiService *AssessmentLibrariesAPIAPIService
	libraryId string
	id string
	bundle *os.File
	assessment *map[string]interface{}
}

// Optional file archive data to be published
func (r ApiAssessmentLibraryUpdateAssessmentRequest) Bundle(bundle *os.File) ApiAssessmentLibraryUpdateAssessmentRequest {
	r.bundle = bundle
	return r
}

func (r ApiAssessmentLibraryUpdateAssessmentRequest) Assessment(assessment map[string]interface{}) ApiAssessmentLibraryUpdateAssessmentRequest {
	r.assessment = &assessment
	return r
}

func (r ApiAssessmentLibraryUpdateAssessmentRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.AssessmentLibraryUpdateAssessmentExecute(r)
}

/*
AssessmentLibraryUpdateAssessment Update assessment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId Library id
 @param id Assessment id
 @return ApiAssessmentLibraryUpdateAssessmentRequest
*/
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryUpdateAssessment(ctx context.Context, libraryId string, id string) ApiAssessmentLibraryUpdateAssessmentRequest {
	return ApiAssessmentLibraryUpdateAssessmentRequest{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		id: id,
	}
}

// Execute executes the request
//  @return interface{}
func (a *AssessmentLibrariesAPIAPIService) AssessmentLibraryUpdateAssessmentExecute(r ApiAssessmentLibraryUpdateAssessmentRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssessmentLibrariesAPIAPIService.AssessmentLibraryUpdateAssessment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/assessment_library/{libraryId}/assessment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"libraryId"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var bundleLocalVarFormFileName string
	var bundleLocalVarFileName     string
	var bundleLocalVarFileBytes    []byte

	bundleLocalVarFormFileName = "bundle"
	bundleLocalVarFile := r.bundle

	if bundleLocalVarFile != nil {
		fbs, _ := io.ReadAll(bundleLocalVarFile)

		bundleLocalVarFileBytes = fbs
		bundleLocalVarFileName = bundleLocalVarFile.Name()
		bundleLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: bundleLocalVarFileBytes, fileName: bundleLocalVarFileName, formFileName: bundleLocalVarFormFileName})
	}
	if r.assessment != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "assessment", r.assessment, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLibrariesRequest struct {
	ctx context.Context
	ApiService *AssessmentLibrariesAPIAPIService
}

func (r ApiListLibrariesRequest) Execute() ([]SocratesLibrary, *http.Response, error) {
	return r.ApiService.ListLibrariesExecute(r)
}

/*
ListLibraries List assessment libraries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListLibrariesRequest
*/
func (a *AssessmentLibrariesAPIAPIService) ListLibraries(ctx context.Context) ApiListLibrariesRequest {
	return ApiListLibrariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SocratesLibrary
func (a *AssessmentLibrariesAPIAPIService) ListLibrariesExecute(r ApiListLibrariesRequest) ([]SocratesLibrary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SocratesLibrary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssessmentLibrariesAPIAPIService.ListLibraries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/assessment_library"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

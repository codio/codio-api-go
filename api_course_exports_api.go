/*
Codio API

Documentation APIs v1.0

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package codioapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CourseExportsAPIAPIService CourseExportsAPIAPI service
type CourseExportsAPIAPIService service

type ApiExportAssessmentDataRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportAssessmentDataRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.ExportAssessmentDataExecute(r)
}

/*
ExportAssessmentData Export Assessment Data CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportAssessmentDataRequest
*/
func (a *CourseExportsAPIAPIService) ExportAssessmentData(ctx context.Context, courseId string) ApiExportAssessmentDataRequest {
	return ApiExportAssessmentDataRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) ExportAssessmentDataExecute(r ApiExportAssessmentDataRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportAssessmentData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/assessments/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportAssignmentCSVRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	assignmentId string
}

func (r ApiExportAssignmentCSVRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ExportAssignmentCSVExecute(r)
}

/*
ExportAssignmentCSV Export Assignment CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param assignmentId Assignment id
 @return ApiExportAssignmentCSVRequest
*/
func (a *CourseExportsAPIAPIService) ExportAssignmentCSV(ctx context.Context, courseId string, assignmentId string) ApiExportAssignmentCSVRequest {
	return ApiExportAssignmentCSVRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		assignmentId: assignmentId,
	}
}

// Execute executes the request
//  @return string
func (a *CourseExportsAPIAPIService) ExportAssignmentCSVExecute(r ApiExportAssignmentCSVRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportAssignmentCSV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/assignments/{assignmentId}/export/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assignmentId"+"}", url.PathEscape(parameterValueToString(r.assignmentId, "assignmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCoachDataRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportCoachDataRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.ExportCoachDataExecute(r)
}

/*
ExportCoachData Export Coach Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportCoachDataRequest
*/
func (a *CourseExportsAPIAPIService) ExportCoachData(ctx context.Context, courseId string) ApiExportCoachDataRequest {
	return ApiExportCoachDataRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) ExportCoachDataExecute(r ApiExportCoachDataRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCoachData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/coach"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCoachDataByTaskRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	taskId string
}

func (r ApiExportCoachDataByTaskRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportCoachDataByTaskExecute(r)
}

/*
ExportCoachDataByTask Fetch Export Coach Data Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param taskId Export task id
 @return ApiExportCoachDataByTaskRequest
*/
func (a *CourseExportsAPIAPIService) ExportCoachDataByTask(ctx context.Context, courseId string, taskId string) ApiExportCoachDataByTaskRequest {
	return ApiExportCoachDataByTaskRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) ExportCoachDataByTaskExecute(r ApiExportCoachDataByTaskRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCoachDataByTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/coach/progress/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseSourceDataItemByTaskRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	taskId string
}

func (r ApiExportCourseSourceDataItemByTaskRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportCourseSourceDataItemByTaskExecute(r)
}

/*
ExportCourseSourceDataItemByTask Fetch Export Sources Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param taskId Export task id
 @return ApiExportCourseSourceDataItemByTaskRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseSourceDataItemByTask(ctx context.Context, courseId string, taskId string) ApiExportCourseSourceDataItemByTaskRequest {
	return ApiExportCourseSourceDataItemByTaskRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) ExportCourseSourceDataItemByTaskExecute(r ApiExportCourseSourceDataItemByTaskRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseSourceDataItemByTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/sources/progress/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseSourceDataItemsRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportCourseSourceDataItemsRequest) Execute() ([]DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportCourseSourceDataItemsExecute(r)
}

/*
ExportCourseSourceDataItems List Exports Course Sources Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportCourseSourceDataItemsRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseSourceDataItems(ctx context.Context, courseId string) ApiExportCourseSourceDataItemsRequest {
	return ApiExportCourseSourceDataItemsRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return []DownloadStatus
func (a *CourseExportsAPIAPIService) ExportCourseSourceDataItemsExecute(r ApiExportCourseSourceDataItemsRequest) ([]DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseSourceDataItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/sources"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseSourcesDataRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportCourseSourcesDataRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.ExportCourseSourcesDataExecute(r)
}

/*
ExportCourseSourcesData Export Course Sources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportCourseSourcesDataRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseSourcesData(ctx context.Context, courseId string) ApiExportCourseSourcesDataRequest {
	return ApiExportCourseSourcesDataRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) ExportCourseSourcesDataExecute(r ApiExportCourseSourcesDataRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseSourcesData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/sources"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseWorkDataRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportCourseWorkDataRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.ExportCourseWorkDataExecute(r)
}

/*
ExportCourseWorkData Export Course Work Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportCourseWorkDataRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseWorkData(ctx context.Context, courseId string) ApiExportCourseWorkDataRequest {
	return ApiExportCourseWorkDataRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) ExportCourseWorkDataExecute(r ApiExportCourseWorkDataRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseWorkData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/workdata"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseWorkDataItemByTaskRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	taskId string
}

func (r ApiExportCourseWorkDataItemByTaskRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportCourseWorkDataItemByTaskExecute(r)
}

/*
ExportCourseWorkDataItemByTask Fetch Export Work Data Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param taskId Export task id
 @return ApiExportCourseWorkDataItemByTaskRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseWorkDataItemByTask(ctx context.Context, courseId string, taskId string) ApiExportCourseWorkDataItemByTaskRequest {
	return ApiExportCourseWorkDataItemByTaskRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) ExportCourseWorkDataItemByTaskExecute(r ApiExportCourseWorkDataItemByTaskRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseWorkDataItemByTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/workdata/progress/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportCourseWorkDataItemsRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportCourseWorkDataItemsRequest) Execute() ([]DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportCourseWorkDataItemsExecute(r)
}

/*
ExportCourseWorkDataItems List Exports Course Work Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportCourseWorkDataItemsRequest
*/
func (a *CourseExportsAPIAPIService) ExportCourseWorkDataItems(ctx context.Context, courseId string) ApiExportCourseWorkDataItemsRequest {
	return ApiExportCourseWorkDataItemsRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return []DownloadStatus
func (a *CourseExportsAPIAPIService) ExportCourseWorkDataItemsExecute(r ApiExportCourseWorkDataItemsRequest) ([]DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportCourseWorkDataItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/workdata"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportLLMProxyDataRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
}

func (r ApiExportLLMProxyDataRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.ExportLLMProxyDataExecute(r)
}

/*
ExportLLMProxyData Export LLMProxy Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @return ApiExportLLMProxyDataRequest
*/
func (a *CourseExportsAPIAPIService) ExportLLMProxyData(ctx context.Context, courseId string) ApiExportLLMProxyDataRequest {
	return ApiExportLLMProxyDataRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) ExportLLMProxyDataExecute(r ApiExportLLMProxyDataRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportLLMProxyData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/llmproxy"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportLLMProxyDataByTaskRouteRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	taskId string
}

func (r ApiExportLLMProxyDataByTaskRouteRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.ExportLLMProxyDataByTaskRouteExecute(r)
}

/*
ExportLLMProxyDataByTaskRoute Fetch Export LLMProxy Data Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param taskId Export task id
 @return ApiExportLLMProxyDataByTaskRouteRequest
*/
func (a *CourseExportsAPIAPIService) ExportLLMProxyDataByTaskRoute(ctx context.Context, courseId string, taskId string) ApiExportLLMProxyDataByTaskRouteRequest {
	return ApiExportLLMProxyDataByTaskRouteRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) ExportLLMProxyDataByTaskRouteExecute(r ApiExportLLMProxyDataByTaskRouteRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportLLMProxyDataByTaskRoute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/llmproxy/progress/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportStudentCSVRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	studentId string
}

func (r ApiExportStudentCSVRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ExportStudentCSVExecute(r)
}

/*
ExportStudentCSV Export Student CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param studentId Student id
 @return ApiExportStudentCSVRequest
*/
func (a *CourseExportsAPIAPIService) ExportStudentCSV(ctx context.Context, courseId string, studentId string) ApiExportStudentCSVRequest {
	return ApiExportStudentCSVRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		studentId: studentId,
	}
}

// Execute executes the request
//  @return string
func (a *CourseExportsAPIAPIService) ExportStudentCSVExecute(r ApiExportStudentCSVRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.ExportStudentCSV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/students/{studentId}/export/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"studentId"+"}", url.PathEscape(parameterValueToString(r.studentId, "studentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDownloadStatusRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	taskId string
}

func (r ApiFetchDownloadStatusRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.FetchDownloadStatusExecute(r)
}

/*
FetchDownloadStatus Fetch Export Assessment Data CSV Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param taskId Export task id
 @return ApiFetchDownloadStatusRequest
*/
func (a *CourseExportsAPIAPIService) FetchDownloadStatus(ctx context.Context, courseId string, taskId string) ApiFetchDownloadStatusRequest {
	return ApiFetchDownloadStatusRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) FetchDownloadStatusExecute(r ApiFetchDownloadStatusRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.FetchDownloadStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/export/assessments/csv/download/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDownloadStatusStudentRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	assignmentId string
	studentId string
	taskId string
}

func (r ApiFetchDownloadStatusStudentRequest) Execute() (*DownloadStatus, *http.Response, error) {
	return r.ApiService.FetchDownloadStatusStudentExecute(r)
}

/*
FetchDownloadStatusStudent Fetch Export Student Data CSV Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param assignmentId Assignment id
 @param studentId Student id
 @param taskId Export task id
 @return ApiFetchDownloadStatusStudentRequest
*/
func (a *CourseExportsAPIAPIService) FetchDownloadStatusStudent(ctx context.Context, courseId string, assignmentId string, studentId string, taskId string) ApiFetchDownloadStatusStudentRequest {
	return ApiFetchDownloadStatusStudentRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		assignmentId: assignmentId,
		studentId: studentId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return DownloadStatus
func (a *CourseExportsAPIAPIService) FetchDownloadStatusStudentExecute(r ApiFetchDownloadStatusStudentRequest) (*DownloadStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.FetchDownloadStatusStudent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/assignments/{assignmentId}/students/{studentId}/download/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assignmentId"+"}", url.PathEscape(parameterValueToString(r.assignmentId, "assignmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"studentId"+"}", url.PathEscape(parameterValueToString(r.studentId, "studentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartedAssignmentDownloadRequest struct {
	ctx context.Context
	ApiService *CourseExportsAPIAPIService
	courseId string
	assignmentId string
	studentId string
}

func (r ApiStartedAssignmentDownloadRequest) Execute() (*TaskProgress, *http.Response, error) {
	return r.ApiService.StartedAssignmentDownloadExecute(r)
}

/*
StartedAssignmentDownload Fetch Export Assessment Data CSV Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param courseId Course id
 @param assignmentId Assignment id
 @param studentId Student id
 @return ApiStartedAssignmentDownloadRequest
*/
func (a *CourseExportsAPIAPIService) StartedAssignmentDownload(ctx context.Context, courseId string, assignmentId string, studentId string) ApiStartedAssignmentDownloadRequest {
	return ApiStartedAssignmentDownloadRequest{
		ApiService: a,
		ctx: ctx,
		courseId: courseId,
		assignmentId: assignmentId,
		studentId: studentId,
	}
}

// Execute executes the request
//  @return TaskProgress
func (a *CourseExportsAPIAPIService) StartedAssignmentDownloadExecute(r ApiStartedAssignmentDownloadRequest) (*TaskProgress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskProgress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CourseExportsAPIAPIService.StartedAssignmentDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/courses/{courseId}/assignments/{assignmentId}/students/{studentId}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"courseId"+"}", url.PathEscape(parameterValueToString(r.courseId, "courseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"assignmentId"+"}", url.PathEscape(parameterValueToString(r.assignmentId, "assignmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"studentId"+"}", url.PathEscape(parameterValueToString(r.studentId, "studentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
